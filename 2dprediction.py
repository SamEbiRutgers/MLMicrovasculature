# -*- coding: utf-8 -*-
"""2Dprediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uio9BzXA2hHXbsxrabAow1_FaWqtL17J
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os

#Specifiy your directory
directory ='/content/In_plane_Velocity'
LL=os.listdir(directory)
np.shape(LL)

"""**Reading and Storing Velocity Profile**"""

#Reading Data
directory ='/content/In_plane_Velocity'
LL=os.listdir(directory)
int(LL[0].replace('fort.',''))

geom8_vel=[]
geom8_ht=[]
for i in range(len(LL)):
  filename=LL[i]
  vessel=int((int(LL[i].replace('fort.',''))-42910000)/100)
  element=int(LL[i].replace('fort.',''))-100*int((int(LL[i].replace('fort.',''))-42910000)/100)-42910000
  f=open(filename,"r")
  lines=f.readlines()
  yy=[]
  vv=[]
  hh=[]
  for x in lines:
    #print(str(x.split()[0]))
    #if str(x.split()[0])=="ZONE":
    # print(str(x.split()[0]))
    if str(x.split()[0])== "Variables=Distance,Vel,Ht" or str(x.split()[0])=="ZONE":
    #  print(str(x.split()[0]),'YY')
      print(str(x.split()[0]))
    else:
      yy.append(float(x.split()[0]))
      vv.append(float(x.split()[1]))
      hh.append(float(x.split()[2]))
  geom8_vel.append([vessel,yy,vv,element])
  geom8_ht.append([vessel,yy,hh,element])
  #plt.plot(yy,vv)
plt.plot(yy,vv)
plt.plot(geom8_vel[0][1],geom8_vel[0][2])

"""**Interpolation**"""

from scipy.interpolate import CubicSpline
gg=[len(geom8_vel[i][1]) for i in range(len(geom8_vel))]
ll=int((np.min(gg)+np.max(gg))*0.5)
ll
print(f'average length of series {ll}')
New_vel=[]
New_ht=[]
for i in range(len(geom8_vel)):
  spl = CubicSpline(geom8_vel[i][1], geom8_vel[i][2])
  max_X=np.max(geom8_vel[i][1])
  y_new=np.linspace(0,max_X,ll)
  New_vel.append([geom8_vel[i][0],y_new,spl(y_new),geom8_vel[i][3]])

  spl = CubicSpline(geom8_ht[i][1], geom8_ht[i][2])
  max_X=np.max(geom8_ht[i][1])
  y_new=np.linspace(0,max_X,ll)
  New_ht.append([geom8_ht[i][0],y_new,spl(y_new),geom8_ht[i][3]])

plt.scatter(New_vel[0][1],New_vel[0][2])
plt.scatter(New_ht[0][1],New_ht[0][2])

"""**Connectivity Between the Mother and Daughter Vessel**"""

df=pd.read_csv("/content/G8FBCCa1.csv")
bif_relation=np.array([[1,	1,	2,	3],
[2,	2,	4,	5],
[3,	3,	6, 7],
[4,	6,	8,	9],
[5,	7,	10,	11],
[6,	9,	12,	13],
[7,	10,	14,	15],
[8,	11,	16,	17],
[9,	12,	18,	19],
[10,	13,	20,	21],
[11,	14,	22,	23],
[12,	15,	24,	25],
[13,	19,	26,	27],
[14,	20,	28,	29],
[15,	21,	30,	31],
[16,	22,	32,	33],
[17,	23,	34,	35],
[18,	26,	36,	37],
[19,	27,	38,	39],
[20,	37,	40,	41],
[21,	39,	42,	43]])
dia=df["dimaeter-dim"]

"""**Index for mothers and daughters**"""

mother_index=[]
daughter1_index=[]
daughter2_index=[]
for bif in range(1,21):
  mother=bif_relation[bif-1][1]
  #print('mother',mother)
  dau1=bif_relation[bif-1][2]
  dau2=bif_relation[bif-1][3]
  am=[]
  ad1=[]
  ad2=[]
  for i in range(len(New_vel)):
    if mother == New_vel[i][0]:
      am.append(i)
    if dau1 == New_vel[i][0]:
      ad1.append(i)
    if dau2 == New_vel[i][0]:
      ad2.append(i)

  if New_vel[am[0]][3]>New_vel[am[1]][3]:
    mother_begin=am[1]
  else:
    mother_begin=am[0]

  mother_index.append([mother, mother_begin,New_vel[mother_begin][3]])

  if New_vel[ad1[0]][3]<New_vel[ad1[1]][3]:
    daughter1_begin=ad1[1]
  else:
    daughter1_begin=ad1[0]

  daughter1_index.append([dau1, daughter1_begin, New_vel[daughter1_begin][3]])

  if New_vel[ad2[0]][3]<New_vel[ad2[1]][3]:
    daughter2_begin=ad2[1]
  else:
    daughter2_begin=ad2[0]

  daughter2_index.append([dau2, daughter2_begin, New_vel[daughter2_begin][3]])

!tar -xzvf g888.tar.gz

import os

Lg8=os.listdir("/content/g888")
Lg8.sort()


def ht_profile(vvv,aa):
  directory ='/content/g888/'
  LL=os.listdir(directory)
  #vvv=51
  #aa=7

  cm=1000
  inx=0
  L1=[]
  for i in range(len(LL)):
    #print(i,LL[i])
    vessel=int((int(LL[i].replace('fort.',''))-42910000)/100)
    element=int(LL[i].replace('fort.',''))-100*int((int(LL[i].replace('fort.',''))-42910000)/100)-42910000
    if vessel ==vvv:
      L1.append(i)

  L2=[]
  for i in range(len(L1)):
    L2.append(LL[L1[i]])

  #L2=L2.sort()
  L2.sort()

  g8_ht_devel=[]
  print(f"Number of elements============={len(L2)}")
  for i in range(2):
    if i==0:
      filename=L2[0+aa]
    #elif i==1:
    #  filename=L2[int(len(L2)/2)]
    else:
      filename=L2[len(L2)-1-aa]
    print(i,filename)
    f=open(filename,"r")
    lines=f.readlines()
    yy=[]
    vv=[]
    hh=[]

    for x in lines:
      #print(str(x.split()[0]))
      #if str(x.split()[0])=="ZONE":
      # print(str(x.split()[0]))
      if str(x.split()[0])== "Variables=Distance,Vel,Ht" or str(x.split()[0])=="ZONE":
      #  print(str(x.split()[0]),'YY')
        print(str(x.split()[0]))
      else:
        yy.append(float(x.split()[0]))
        vv.append(float(x.split()[1]))
        hh.append(float(x.split()[2]))
    #plt.plot(vv)
    #geom9_vel.append([vessel,yy,vv,element])
    #geom9_ht.append([vessel,yy,hh,element])
    #g8_ht_devel.append([filename,hh])
    g8_ht_devel.append([filename,vvv,yy,hh])

  plt.figure(figsize=(20,5))
  plt.subplot(1,3,1)
  plt.plot(g8_ht_devel[0][3], label='Begining of the vessel', c='r')
  plt.legend()
  plt.ylim([0,0.7])
  #plt.xlim([0,200])
  plt.subplot(1,3,2)
  plt.plot(g8_ht_devel[1][3], label='End of vessel',c='b')
  plt.legend()
  plt.ylim([0,0.7])
  #plt.subplot(1,3,3)
  #plt.plot(g8_ht_devel[2][1], label='End of vessel',c='g')
  #plt.legend()
  plt.title('vessel'+str(vvv))
  #plt.ylim([0,0.7])
  return g8_ht_devel

VI=10
A=ht_profile(VI,1)

"""Interpolation

#** smoothing hematocirt data**
"""

from scipy.interpolate import make_interp_spline, BSpline
count=0
y_train =y_train1.copy()
y_train_new=np.zeros(np.shape(y_train))
for v in range(len(y_train)):
  count =count+1
  plt.figure(figsize=(50,50))
  plt.subplot(11,4,count)
  plt.plot(np.arange(0,ll),y_train[v,:])
  spl=make_interp_spline(np.arange(0,ll),y_train[v,:],k=5)#spl = CubicSpline(np.arange(0,ll),x_train[0,ll:])
  #spl = CubicSpline(np.arange(0,ll),x_train[0,ll:])
  def smoothing(lll,L1, L2,k, step,x1,y1):
    max_X=np.max(np.arange(0,ll))
    a=np.arange(0,L1,1)
    b=np.arange(L1,L2,step)
    c=np.arange(L2,lll,1)
    y_new=np.concatenate((a,b))
    y_new=np.concatenate((y_new,c))
    #spl=make_interp_spline(np.arange(0,lll),x_train[v,lll:],k)
    spl=make_interp_spline(x1,y1,k)
    return y_new, spl(y_new)

  xx=np.arange(0,ll)
  yy=y_train[v,:]
  for i in range(3):

    #xx,yy=smoothing(ll,10, 46, 2, 2,xx,yy)
    xx,yy=smoothing(ll,8, 48, 1, 2,xx,yy)
    xx,yy=smoothing(ll,8, 48, 2, 7,xx,yy)
    xx,yy=smoothing(ll,8, 48, 2, 1,xx,yy)

  #print(np.shape(yy))
  for j in range(ll):
    y_train[v,j]=yy[j]
  plt.plot(xx,yy)

  ###############
  count =count+1
  y_train =y_train1.copy()
  plt.subplot(11,4,count)
  plt.plot(np.arange(0,ll),y_train[v,:])
  spl=make_interp_spline(np.arange(0,ll),y_train[v,:],k=5)#spl = CubicSpline(np.arange(0,ll),x_train[0,ll:])
  #spl = CubicSpline(np.arange(0,ll),x_train[0,ll:])
  def smoothing(lll,L1, L2,k, step,x1,y1):
    max_X=np.max(np.arange(0,ll))
    a=np.arange(0,L1,1)
    b=np.arange(L1,L2,step)
    c=np.arange(L2,lll,1)
    y_new=np.concatenate((a,b))
    y_new=np.concatenate((y_new,c))
    #spl=make_interp_spline(np.arange(0,lll),x_train[v,lll:],k)
    spl=make_interp_spline(x1,y1,k)
    return y_new, spl(y_new)

  xx=np.arange(0,ll)
  yy=y_train[v,:]
  for i in range(3):


    #xx,yy=smoothing(ll,10, 46, 1, 9,xx,yy)
    #xx,yy=smoothing(ll,10, 46, 2, 7,xx,yy)
    #xx,yy=smoothing(ll,10, 46, 2, 1,xx,yy)
    xx,yy=smoothing(ll,8, 48, 1, 9,xx,yy)
    xx,yy=smoothing(ll,8, 48, 2, 7,xx,yy)
    xx,yy=smoothing(ll,8, 48, 2, 1,xx,yy)

  print(np.shape(yy))
  for j in range(ll):
    y_train[v,j]=yy[j]
  plt.plot(xx,yy)

  for j in range(ll):
    y_train_new[v,j]=yy[j]
  ###############
  #plt.plot(np.arange(0,ll),x_train[v,ll:])

plt.show()

plt.plot(y_train_new[-3])

"""# **New_Smoothing for the x_tarin[,:ll]**

#**New ML models for the bifurcartions**
"""

import tensorflow as tf
from tensorflow.keras.layers import Dense, Input
from tensorflow.keras.models import Sequential, Model

model4 = Sequential([Dense(10, activation='relu',input_shape=(1*ll,)),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(800, activation='relu'),
                    Dense(1*ll, activation='relu')
                    ])
'''
x=Input(shape=(ll,))
h=Dense(20, activation='relu')(x)
h=Dense(50, activation='relu')(h)
h=Dense(50, activation='relu')(h)
h=Dense(50, activation='relu')(h)
out1=Dense(ll, activation='relu')(h)
out2=Dense(ll,activation='relu')(h)
'''
model4.compile(loss='mse',optimizer='Adam',metrics=['mae'])
model4.summary()
history=model4.fit(x_train_new,y_train_new, epochs=20000, shuffle = True )

model4.save("/content/model_bif_ht_left.h5")

"""#**Prediction for Test Dataset**"""

!tar -zxvf test_g9.tar.gz

import os

def ht_profile_g9(vvv,aa):
  directory ='/content/test_g9/'
  LL=os.listdir(directory)
  #vvv=51
  #aa=7

  cm=1000
  inx=0
  L1=[]
  for i in range(len(LL)):
    #print(i,LL[i])
    vessel=int((int(LL[i].replace('fort.',''))-42910000)/100)
    element=int(LL[i].replace('fort.',''))-100*int((int(LL[i].replace('fort.',''))-42910000)/100)-42910000
    if vessel ==vvv:
      L1.append(i)

  L2=[]
  for i in range(len(L1)):
    L2.append(LL[L1[i]])

  #L2=L2.sort()
  L2.sort()

  #g8_ht_devel=[]
  g9_ht_devel=[]
  print(f"Number of elements============={len(L2)}")
  for i in range(2):
    if i==0:
      filename=L2[0+aa]
    #elif i==1:
    #  filename=L2[int(len(L2)/2)]
    else:
      filename=L2[len(L2)-1-aa]
    print(i,filename)
    f=open(filename,"r")
    lines=f.readlines()
    yy=[]
    vv=[]
    hh=[]

    for x in lines:
      #print(str(x.split()[0]))
      #if str(x.split()[0])=="ZONE":
      # print(str(x.split()[0]))
      if str(x.split()[0])== "Variables=Distance,Vel,Ht" or str(x.split()[0])=="ZONE":
      #  print(str(x.split()[0]),'YY')
        print(str(x.split()[0]))
      else:
        yy.append(float(x.split()[0]))
        vv.append(float(x.split()[1]))
        hh.append(float(x.split()[2]))
    #plt.plot(vv)
    #geom9_vel.append([vessel,yy,vv,element])
    #geom9_ht.append([vessel,yy,hh,element])
    #g8_ht_devel.append([filename,hh])
    g9_ht_devel.append([filename,vvv,yy,hh])

  plt.figure(figsize=(20,5))
  plt.subplot(1,3,1)
  plt.plot(g9_ht_devel[0][3], label='Begining of the vessel', c='r')
  plt.legend()
  plt.ylim([0,0.7])
  #plt.xlim([0,200])
  plt.subplot(1,3,2)
  plt.plot(g9_ht_devel[1][3], label='End of vessel',c='b')
  plt.legend()
  plt.ylim([0,0.7])
  #plt.subplot(1,3,3)
  #plt.plot(g8_ht_devel[2][1], label='End of vessel',c='g')
  #plt.legend()
  plt.title('vessel'+str(vvv))
  #plt.ylim([0,0.7])
  return g9_ht_devel

"""#**Select your mother daughter vessels IDs**



"""

vessel_g9_rel=[65,52,66]

VI=vessel_g9_rel[0]
hh=ht_profile_g9(VI,1)[1][3]
yy=ht_profile_g9(VI,1)[1][2]
spl = CubicSpline(yy,hh)
y_new=np.linspace(0,np.max(yy),ll)
ht_pr1=np.zeros((ll,1))
for j in range(ll):
  ht_pr1[j,0]=spl(y_new)[j]

VI=vessel_g9_rel[1]
hh=ht_profile_g9(VI,1)[1][3]
yy=ht_profile_g9(VI,1)[1][2]
spl = CubicSpline(yy,hh)
y_new=np.linspace(0,np.max(yy),ll)
ht_pr2=np.zeros((ll,1))
for j in range(ll):
  ht_pr2[j,0]=spl(y_new)[j]


VI=vessel_g9_rel[2]
hh=ht_profile_g9(VI,1)[0][3]
yy=ht_profile_g9(VI,1)[0][2]
spl = CubicSpline(yy,hh)
y_new=np.linspace(0,np.max(yy),ll)
ht_test=np.zeros((ll,1))
for j in range(ll):
  ht_test[j,0]=spl(y_new)[j]

#VI=vessel_g9_rel[1]
#ht_pr2=ht_profile_g9(VI,1)[1][3]

#VI=vessel_g9_rel[0]
#ht_test=ht_profile_g9(VI,1)[0][3]

"""#FOR PREDICTION

"""

ht_pr1,ht_test,mmm,ddd = hema_for_prediction(ht_profile_g9,[25,28],3,2)

#Predicting the Results
A1=model.predict((ht_pr1).reshape(1,ll*1)).reshape(ll,1)

#showing the Predicted vs DNS
plt.plot(np.arange(len(hh1))/56*8,hh1*1, label='predicted')
plt.plot(np.arange(len(hh))/56*8,hh)